diff -urp httpd-2.2.24.org/server/mpm_common.c httpd-2.2.24/server/mpm_common.c
--- httpd-2.2.24.org/server/mpm_common.c	2013-02-16 23:51:16.000000000 +0100
+++ httpd-2.2.24/server/mpm_common.c	2013-04-10 21:25:06.322056566 +0200
@@ -648,6 +648,7 @@ static apr_status_t dummy_connection(ap_
     apr_socket_t *sock;
     apr_pool_t *p;
     apr_size_t len;
+    ap_listen_rec *lp;
 
     /* create a temporary pool for the socket.  pconf stays around too long */
     rv = apr_pool_create(&p, pod->p);
@@ -655,8 +656,19 @@ static apr_status_t dummy_connection(ap_
         return rv;
     }
 
-    rv = apr_socket_create(&sock, ap_listeners->bind_addr->family,
-                           SOCK_STREAM, 0, p);
+    /* If possible, find a listener which is configured for
+     * plain-HTTP, not SSL; using an SSL port would either be
+     * expensive to do correctly (performing a complete SSL handshake)
+     * or cause log spam by doing incorrectly (simply sending EOF). */
+    lp = ap_listeners;
+    while (lp && lp->protocol && strcasecmp(lp->protocol, "http") != 0) {
+        lp = lp->next;
+    }
+    if (!lp) {
+        lp = ap_listeners;
+    }
+
+    rv = apr_socket_create(&sock, lp->bind_addr->family, SOCK_STREAM, 0, p);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
                      "get socket to connect to listener");
@@ -679,7 +691,7 @@ static apr_status_t dummy_connection(ap_
         return rv;
     }
 
-    rv = apr_socket_connect(sock, ap_listeners->bind_addr);
+    rv = apr_socket_connect(sock, lp->bind_addr);
     if (rv != APR_SUCCESS) {
         int log_level = APLOG_WARNING;
 
@@ -692,12 +704,12 @@ static apr_status_t dummy_connection(ap_
         }
 
         ap_log_error(APLOG_MARK, log_level, rv, ap_server_conf,
-                     "connect to listener on %pI", ap_listeners->bind_addr);
+                     "connect to listener on %pI", lp->bind_addr);
         apr_pool_destroy(p);
         return rv;
     }
 
-    if (ap_listeners->protocol && strcasecmp(ap_listeners->protocol, "https") == 0) {
+    if (lp->protocol && strcasecmp(lp->protocol, "https") == 0) {
         /* Send a TLS 1.0 close_notify alert.  This is perhaps the
          * "least wrong" way to open and cleanly terminate an SSL
          * connection.  It should "work" without noisy error logs if
