
Update to HEAD's ab which seems to be slightly less utterly borked
than 2.0's.

--- httpd-2.0.48/support/ab.c.abench
+++ httpd-2.0.48/support/ab.c
@@ -1,7 +1,7 @@
 /* ====================================================================
  * The Apache Software License, Version 1.1
  *
- * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
+ * Copyright (c) 2000-2004 The Apache Software Foundation.  All rights
  * reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -103,9 +103,9 @@
    ** Version 2.0.36-dev
    **    Improvements to concurrent processing:
    **      - Enabled non-blocking connect()s.
-   **      - Prevent blocking calls to apr_recv() (thereby allowing AB to
+   **      - Prevent blocking calls to apr_socket_recv() (thereby allowing AB to
    **        manage its entire set of socket descriptors).
-   **      - Any error returned from apr_recv() that is not EAGAIN or EOF
+   **      - Any error returned from apr_socket_recv() that is not EAGAIN or EOF
    **        is now treated as fatal.
    **      Contributed by Aaron Bannert, April 24, 2002
    **
@@ -185,9 +185,30 @@
 #endif
 #if APR_HAVE_STDLIB_H
 #include <stdlib.h>
+#endif
+#if APR_HAVE_UNISTD_H
+#include <unistd.h> /* for getpid() */
+#endif
+
+#if !defined(WIN32) && !defined(NETWARE)
+#include "ap_config_auto.h"
+#endif
+
+#if defined(HAVE_SSLC)
+
+/* Libraries for RSA SSL-C */
+#include <rsa.h>
+#include <x509.h>
+#include <pem.h>
+#include <err.h>
+#include <ssl.h>
+#include <r_rand.h>
+#include <sslc.h>
+#define USE_SSL
+#define RSAREF
+
+#elif defined(HAVE_OPENSSL)
 
-#ifdef	USE_SSL
-#if ((!(RSAREF)) && (!(SYSSSL)))
 /* Libraries on most systems.. */
 #include <openssl/rsa.h>
 #include <openssl/crypto.h>
@@ -196,20 +217,11 @@
 #include <openssl/err.h>
 #include <openssl/ssl.h>
 #include <openssl/rand.h>
-#else
-/* Libraries for RSAref and SYSSSL */
-#include <rsa.h>
-#include <crypto.h>
-#include <x509.h>
-#include <pem.h>
-#include <err.h>
-#include <ssl.h>
-#include <rand.h>
-#endif
+#define USE_SSL
+
 #endif
 
 #include <math.h>
-#endif
 #if APR_HAVE_CTYPE_H
 #include <ctype.h>
 #endif
@@ -227,8 +239,11 @@
 
 /* good old state hostname */
 #define STATE_UNCONNECTED 0
-#define STATE_CONNECTING  1
-#define STATE_READ        2
+#define STATE_CONNECTING  1     /* TCP connect initiated, but we don't
+                                 * know if it worked yet
+                                 */
+#define STATE_CONNECTED   2     /* we know TCP connect completed */
+#define STATE_READ        3
 
 #define CBUFFSIZE (2048)
 
@@ -463,7 +478,7 @@
  *
  */
 #ifdef USE_SSL
-long ssl_print_cb(BIO *bio,int cmd,const char *argp,int argi,long argl,long ret)
+static long ssl_print_cb(BIO *bio,int cmd,const char *argp,int argi,long argl,long ret)
 {
     BIO *out;
 
@@ -505,7 +520,7 @@
     return i;
 }
 
-void ssl_rand_seed()
+static void ssl_rand_seed(void)
 {
     int nDone = 0;
     int n, l;
@@ -537,9 +552,7 @@
     nDone += 128;
 }
 
-int ssl_print_connection_info(bio,ssl)
-BIO *bio;
-SSL *ssl;
+static int ssl_print_connection_info(BIO *bio, SSL *ssl)
 {
         SSL_CIPHER *c;
         int alg_bits,bits;
@@ -554,9 +567,7 @@
         return(1);
 }
 
-int ssl_print_cert_info(bio,x509cert)
-BIO *bio;
-X509 *x509cert;
+static int ssl_print_cert_info(BIO *bio, X509 *x509cert)
 {
         X509_NAME *dn;
         char buf[64];
@@ -588,7 +599,7 @@
         return(1);
 }
 
-void ssl_start_connect(struct connection * c)
+static void ssl_start_connect(struct connection * c)
 {
     BIO *bio;
     X509 *x509cert;
@@ -668,7 +679,7 @@
             case SSL_ERROR_WANT_CONNECT:
                 BIO_printf(bio_err, "Waiting .. sleep(1)\n");
                 apr_sleep(apr_time_from_sec(1));
-                c->state = STATE_CONNECTING;
+                c->state = STATE_CONNECTED;
                 c->rwrite = 0;
                 break;
             case SSL_ERROR_ZERO_RETURN:
@@ -724,7 +735,7 @@
     do {
 	apr_time_t tnow = apr_time_now();
 	apr_size_t l = c->rwrite;
-	apr_status_t e;
+	apr_status_t e = APR_SUCCESS; /* prevent gcc warning */
 
 	/*
 	 * First time round ?
@@ -760,7 +771,7 @@
         }
         else
 #endif
-	e = apr_send(c->aprsock, request + c->rwrote, &l);
+	e = apr_socket_send(c->aprsock, request + c->rwrote, &l);
 
 	/*
 	 * Bail early on the most common case
@@ -770,6 +781,7 @@
 
 #ifdef USE_SSL
         if (ssl != 1)
+#endif
 	if (e != APR_SUCCESS) {
 	    /*
 	     * Let's hope this traps EWOULDBLOCK too !
@@ -781,7 +793,6 @@
 	    }
 	    return;
 	}
-#endif
 	c->rwrote += l;
 	c->rwrite -= l;
     } while (1);
@@ -1250,13 +1261,13 @@
         apr_err("socket nonblock", rv);
     }
     c->start = apr_time_now();
-    if ((rv = apr_connect(c->aprsock, destsa)) != APR_SUCCESS) {
+    if ((rv = apr_socket_connect(c->aprsock, destsa)) != APR_SUCCESS) {
 	if (APR_STATUS_IS_EINPROGRESS(rv)) {
             apr_pollfd_t new_pollfd;
 	    c->state = STATE_CONNECTING;
 	    c->rwrite = 0;
             new_pollfd.desc_type = APR_POLL_SOCKET;
-            new_pollfd.reqevents = APR_POLLOUT | APR_POLLIN;
+            new_pollfd.reqevents = APR_POLLOUT;
             new_pollfd.desc.s = c->aprsock;
             new_pollfd.client_data = c;
 	    apr_pollset_add(readbits, &new_pollfd);
@@ -1272,7 +1283,7 @@
 	    if (bad++ > 10) {
 		fprintf(stderr,
 			"\nTest aborted after 10 failures\n\n");
-		apr_err("apr_connect()", rv);
+		apr_err("apr_socket_connect()", rv);
 	    }
 	    c->state = STATE_UNCONNECTED;
 	    start_connect(c);
@@ -1281,6 +1292,7 @@
     }
 
     /* connected first time */
+    c->state = STATE_CONNECTED;
     started++;
     write_request(c);
 }
@@ -1371,7 +1383,7 @@
     }
     else {
 #endif
-    status = apr_recv(c->aprsock, buffer, &r);
+    status = apr_socket_recv(c->aprsock, buffer, &r);
     if (APR_STATUS_IS_EAGAIN(status))
 	return;
     else if (r == 0 && APR_STATUS_IS_EOF(status)) {
@@ -1379,12 +1391,12 @@
 	close_connection(c);
 	return;
     }
-    /* catch legitimate fatal apr_recv errors */
+    /* catch legitimate fatal apr_socket_recv errors */
     else if (status != APR_SUCCESS) {
         err_except++; /* XXX: is this the right error counter? */
         /* XXX: Should errors here be fatal, or should we allow a
          * certain number of them before completely failing? -aaron */
-        apr_err("apr_recv", status);
+        apr_err("apr_socket_recv", status);
     }
 #ifdef USE_SSL
     }
@@ -1633,7 +1645,11 @@
      * Combine headers and (optional) post file into one contineous buffer
      */
     if (posting == 1) {
-	char *buff = (char *) malloc(postlen + reqlen + 1);
+	char *buff = malloc(postlen + reqlen + 1);
+        if (!buff) {
+            fprintf(stderr, "error creating request buffer: out of memory\n");
+            return;
+        }
 	strcpy(buff, request);
 	strcpy(buff + reqlen, postdata);
 	request = buff;
@@ -1700,7 +1716,14 @@
 
 	for (i = 0; i < n; i++) {
             const apr_pollfd_t *next_fd = &(pollresults[i]);
-            struct connection *c = next_fd->client_data;
+            struct connection *c;
+            
+#ifdef USE_SSL
+            if (ssl) 
+                c = &con[i];
+            else
+#endif
+                c = next_fd->client_data;
 
 	    /*
 	     * If the connection isn't connected how can we check it?
@@ -1735,8 +1758,34 @@
 		start_connect(c);
 		continue;
 	    }
-	    if (rv & APR_POLLOUT)
-		write_request(c);
+	    if (rv & APR_POLLOUT) {
+                if (c->state == STATE_CONNECTING) {
+                    apr_pollfd_t remove_pollfd;
+                    rv = apr_socket_connect(c->aprsock, destsa);
+                    remove_pollfd.desc_type = APR_POLL_SOCKET;
+                    remove_pollfd.desc.s = c->aprsock;
+                    apr_pollset_remove(readbits, &remove_pollfd);
+                    if (rv != APR_SUCCESS) {
+                        apr_socket_close(c->aprsock);
+                        err_conn++;
+                        if (bad++ > 10) {
+                            fprintf(stderr,
+                                    "\nTest aborted after 10 failures\n\n");
+                            apr_err("apr_socket_connect()", rv);
+                        }
+                        c->state = STATE_UNCONNECTED;
+                        start_connect(c);
+                        continue;
+                    }
+                    else {
+                        c->state = STATE_CONNECTED;
+                        write_request(c);
+                    }
+                }
+                else {
+                    write_request(c);
+                }
+            }
 
 	    /*
 	     * When using a select based poll every time we check the bits
@@ -1748,8 +1797,7 @@
 #ifdef USE_SSL
             if (ssl != 1)
 #endif
-	    if (c->state == STATE_READ ||
-                c->state == STATE_CONNECTING) {
+                if (c->state == STATE_READ) {
                     apr_pollfd_t new_pollfd;
                     new_pollfd.desc_type = APR_POLL_SOCKET;
                     new_pollfd.reqevents = APR_POLLIN;
@@ -1777,14 +1825,14 @@
 static void copyright(void)
 {
     if (!use_html) {
-	printf("This is ApacheBench, Version %s\n", AP_AB_BASEREVISION " <$Revision$> apache-2.0");
+	printf("This is ApacheBench, Version %s\n", AP_AB_BASEREVISION " <$Revision$> apache-2.0");
 	printf("Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\n");
 	printf("Copyright (c) 1998-2002 The Apache Software Foundation, http://www.apache.org/\n");
 	printf("\n");
     }
     else {
 	printf("<p>\n");
-	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-2.0<br>\n", AP_AB_BASEREVISION, "$Revision$");
+	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-2.0<br>\n", AP_AB_BASEREVISION, "$Revision$");
 	printf(" Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>\n");
 	printf(" Copyright (c) 1998-2002 The Apache Software Foundation, http://www.apache.org/<br>\n");
 	printf("</p>\n<p>\n");
